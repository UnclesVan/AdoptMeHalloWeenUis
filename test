-- Full Script with correct order and consolidated UI and game logic

print("Script Version: 2025-07-07_ConsolidatedUIAndLogic_v111")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui") -- Re-added CoreGui service

-- Ensure character and humanoidrootpart are available from the start, with robust checks
local character = player.Character
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

print("Character loaded:", character.Name)
print("Humanoid loaded.")
print("HumanoidRootPart loaded.")

-- NEW: Early check for Workspace.Interiors
local interiorsFolder = workspace:FindFirstChild("Interiors")
if not interiorsFolder or not (interiorsFolder:IsA("Folder") or interiorsFolder:IsA("Model")) then
    warn("!!! SCRIPT ABORTED: 'Workspace.Interiors' NOT FOUND or is not a valid container (Folder/Model). No automated features will run. !!!")
    -- We won't return here immediately, as the UI should still load.
    -- The automated features will simply not activate.
else
    print("'Workspace.Interiors' found. Proceeding with teleport path validation.")
end


-- --- SCRIPT STATE ---
local scriptEnabled = false -- Controls the main script loop
local hotbarSpamActive = true -- Example feature state (controlled by scriptEnabled's main loop)
local teleportToRaidersActive = true -- ONLY THIS TELEPORT IS ACTIVE (controlled by scriptEnabled's main loop)
local scoreIncreasingActionsAllowed = true
local hasClickedStartButton = false
-- Auto close reward and auto click hotbar are NOT included in this version.

-- NEW: Automated Boat Teleportation States
local isBoatTeleportCycleRunning = false -- Controls the automated boat teleport cycle (now controlled by button)
local hasLoggedBoatFound = false -- To _log "found" message only once per transition for boats
local hasLoggedInvalidPaths = false -- To _log "invalid paths" message only once per transition

-- --- CONFIGURATION ---
local FROSTCLAWS_HOTBAR_APP_NAME = "MinigameHotbarApp"
local DROP_BUTTON_NAME = "DropButton"
local SWORD_BUTTON_NAME = "SwordButton"
local EXCLUDED_MODEL_KEYWORDS = {"parrot", "cage"} -- Models to exclude from teleportation
local COCONUT_BONK_INTERIOR_BASE_NAME = "CoconutBonkInterior"
local GOLD_PILE_GUARD_RADIUS = 30 -- Radius around GoldPile to detect raiders
local TARGET_SCORE = 1600
local SCORE_UPPER_TOLERANCE = 50
local SCORE_LOWER_TOLERANCE = 50
local MAX_CONSOLE_LINES = 20
local LOG_FINDING_COOLDOWN = 5 -- Seconds before repeating a "Finding..." message

-- Noclip Settings (AUTOMATICALLY ACTIVE when boat teleport is active)
local NoclipWalkSpeed = 40        -- Walk speed when Noclipping
local NoclipJumpPower = 0         -- Jump power when Noclipping
local NoclipAutoJumpEnabled = false -- AutoJump setting when Noclipping

-- Floating Settings (using BodyVelocity for a hover effect)
local FloatVelocity = Vector3.new(0, 0, 0) -- Target velocity for floating (makes it hover)
local FloatMaxForce = Vector3.new(0, math.huge, 0) -- Max force to apply (very high for upward)
local isFloating = false -- Internal state for floating

-- Automated Teleport Settings (for boats)
-- These paths are now relative to the 'Game' folder found within CoconutBonkInterior
local TeleportLocationPaths = {
    {"Bins", "Boats", "Boat", "RopeStart"}, -- Path for the first "Boat" model by name (Correct)
    {"Bins", "Boats", {type = "index", value = 2}, "RopeStart"}, -- Path for the second "Boat" model using its index in GetChildren()
    {"Bins", "Boats", "Sailboat", "RopeStart"} -- Path for the "Sailboat" model by name (Correct)
}
local TeleportDelay = 3 -- Delay in seconds between each automated teleport
local THREAT_HANDLING_DELAY = 3 -- New: Delay after teleporting to a raider before resuming boat cycle

-- Store original character properties to restore them (if needed later)
local originalWalkSpeed = humanoid.WalkSpeed
local originalJumpPower = humanoid.JumpPower
local originalAutoJumpEnabled = humanoid.AutoJumpEnabled

-- // --- INTERNAL VARIABLES (DO NOT MODIFY) --- //
local isNoclipping = false -- Will be set to true automatically
local currentTeleportIndex = 1 -- Keep track of current location in the cycle
local ValidTeleportTargets = {} -- This will store {part = PartInstance, debugPath = "path.string"}

-- NEW: Global state to indicate if a threat was detected and handled (teleported to)
local isThreatDetectedAndHandled = false

-- --- INTERNAL ---
local consoleTextLabel = nil -- Reference to the TextLabel for logging
local lastLogTime = {} -- For _logFinding cooldowns
local findingMinigameCoroutine = nil -- To manage the "finding minigame..." loop
local findingBoatMinigameCoroutine = nil -- New: To manage the "finding boat minigame..." loop
local isFindingBoatMinigame = false -- New: State for boat finding messages
local boatTeleportationTask = nil -- To manage the actual teleportation coroutine

-- NEW: Reference to the main console ScreenGui itself
local mainConsoleGui: ScreenGui


-- --- CORE FUNCTIONS ---

-- Utility function for logging to the console UI (now global)
function log(message, debugTag)
    if consoleTextLabel then
        local success, err = pcall(function()
            local timestamp = os.date("%H:%M:%S", os.time())
            local formattedMessage = "[" .. timestamp .. "] " .. tostring(message)
            if debugTag then
                formattedMessage = formattedMessage .. " " .. debugTag
            end

            local currentText = consoleTextLabel.Text
            local lines = {}
            -- Split by newline, handling empty lines correctly
            for line in currentText:gmatch("([^\n]*)\n?") do
                if line ~= "" then
                    table.insert(lines, line)
                end
            end

            -- Limit lines to prevent console overflow
            if #lines >= MAX_CONSOLE_LINES then
                table.remove(lines, 1) -- Remove oldest line
            end

            table.insert(lines, formattedMessage)
            consoleTextLabel.Text = table.concat(lines, "\n")
            -- Auto-scroll to bottom
            local textScroller = consoleTextLabel.Parent
            if textScroller and textScroller:IsA("ScrollingFrame") then
                textScroller.CanvasPosition = Vector2.new(0, textScroller.CanvasSize.Y.Offset - textScroller.AbsoluteSize.Y)
            end
        end)
        if not success then
            warn("Error writing to consoleTextLabel: " .. tostring(err))
            print(message) -- Fallback to Roblox output if UI write fails
        end
    else
        print(message) -- Fallback to Roblox output if console UI not ready
    end
end

-- Log function with cooldown for "finding" messages (now global)
function logFinding(key, messageName, isFound)
    local currentTime = tick()
    if isFound then
        if lastLogTime[key] ~= "found" then
            _log(messageName .. " found!")
            lastLogTime[key] = "found"
        end
    else
        if lastLogTime[key] == "found" then
            _log(messageName .. " not found. Searching...")
            lastLogTime[key] = currentTime
        elseif not lastLogTime[key] or (currentTime - lastLogTime[key]) >= LOG_FINDING_COOLDOWN then
            _log("Finding " .. messageName .. "...")
            lastLogTime[key] = currentTime
        end
    end
end

-- Cache global functions into local variables for safer access
local _log = log
local _logFinding = logFinding


-- Function to set collision for all character parts
local function setCharacterCollisions(canCollide)
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.CanCollide = canCollide
        end
    end
end

-- Function to activate Noclip automatically
local function activateNoclip()
    if not isNoclipping then
        isNoclipping = true
        _log("[Utility] Noclip: ACTIVATING AUTOMATICALLY.")
        humanoid.WalkSpeed = NoclipWalkSpeed
        humanoid.JumpPower = NoclipJumpPower
        humanoid.AutoJumpEnabled = NoclipAutoJumpEnabled
        setCharacterCollisions(false) -- Disable collisions
        _log("[Utility] Noclip: AUTOMATICALLY ON.")
    end
end

-- Function to deactivate Noclip
local function deactivateNoclip()
    if isNoclipping then
        isNoclipping = false
        _log("[Utility] Noclip: DEACTIVATING.")
        humanoid.WalkSpeed = originalWalkSpeed
        humanoid.JumpPower = originalJumpPower
        humanoid.AutoJumpEnabled = originalAutoJumpEnabled
        setCharacterCollisions(true) -- Enable collisions
        _log("[Utility] Noclip: OFF.")
    end
end

-- Function to toggle Floating (using BodyVelocity for a hover effect)
local function toggleFloating(forceOn)
    -- If forceOn is true, it will always try to turn floating ON.
    -- If forceOn is false, it will always try to turn floating OFF.
    -- If forceOn is nil, it will toggle the state.

    local newState = isFloating
    if forceOn ~= nil then
        newState = forceOn
    else
        newState = not isFloating
    end

    if newState and not isFloating then -- Turn ON
        isFloating = true
        _log("[Utility] Floating: Attempting to turn ON (BodyVelocity).")
        local bodyVelocity = humanoidRootPart:FindFirstChild("WRDBodyVelocity")
        if not bodyVelocity then
            bodyVelocity = Instance.new("BodyVelocity")
            bodyVelocity.Name = "WRDBodyVelocity"
            bodyVelocity.Parent = humanoidRootPart
            _log("[Utility] Floating: Created new BodyVelocity.")
        end
        bodyVelocity.MaxForce = FloatMaxForce
        bodyVelocity.Velocity = FloatVelocity
        humanoid.WalkSpeed = 0 -- Stop horizontal movement while truly floating
        humanoid.Sit = false -- Ensure not sitting
        _log("[Utility] Floating: ON (BodyVelocity Applied).")
    elseif not newState and isFloating then -- Turn OFF
        isFloating = false
        _log("[Utility] Floating: Attempting to turn OFF.")
        local bodyVelocity = humanoidRootPart:FindFirstChild("WRDBodyVelocity")
        if bodyVelocity then
            bodyVelocity:Destroy()
            _log("[Utility] Floating: Destroyed BodyVelocity.")
        end
        humanoid.WalkSpeed = originalWalkSpeed -- Restore original walkspeed
        _log("[Utility] Floating: OFF.")
    end
end

-- New dynamic path finding function (now LOCAL and uniquely named)
local function _findInstanceByPath(base, fullPathString, timeoutPerAttempt, maxAttempts)
    timeoutPerAttempt = timeoutPerAttempt or 0.2 -- How long to wait per attempt
    maxAttempts = maxAttempts or 3              -- How many times to retry finding each part

    local currentElement = base
    local pathParts = string.split(fullPathString, ".")

    for i, partName in ipairs(pathParts) do
        local found = false
        local attempts = 0
        local elementToFind = partName

        while not found and attempts < maxAttempts do
            attempts = attempts + 1
            local result = currentElement:WaitForChild(elementToFind, timeoutPerAttempt)

            if result then
                currentElement = result
                found = true
            else
                if i == #pathParts and attempts < maxAttempts then
                    -- print("Retrying (" .. attempts .. "/" .. maxAttempts .. ") to find '" .. elementToFind .. "' for path: " .. fullPathString)
                elseif i == #pathParts and attempts == maxAttempts then
                    -- warn("Failed to find '" .. elementToElement .. "' for path '" .. fullPathString .. "' after " .. maxAttempts .. " attempts.")
                end
            end
        end

        if not found then
            return nil -- If any part of the path is not found after maxAttempts, return nil
        end
    end
    return currentElement
end

-- Function to perform a single float-teleport
local function performFloatTeleport(targetPart)
    if targetPart and targetPart.part and targetPart.part:IsA("BasePart") then
        local partInstance = targetPart.part
        _log("[Utility] Teleport: Calculating CFrame for " .. partInstance.Name .. " (Path: " .. targetPart.debugPath .. ")")
        local targetPosition = partInstance.CFrame.Position
        local newCFrame = CFrame.new(targetPosition + Vector3.new(0, humanoidRootPart.Size.Y / 2 + 0.1, 0))

        humanoidRootPart.CFrame = newCFrame
        _log("[Utility] Teleport: Teleported character to " .. partInstance.Name .. " at " .. tostring(targetPosition))

        -- Ensure floating is active after teleport
        if not isFloating then
            toggleFloating(true)
        else
            _log("[Utility] Teleport: Character already floating, re-applying BodyVelocity properties.")
            local bodyVelocity = humanoidRootPart:FindFirstChild("WRDBodyVelocity")
            if not bodyVelocity then
                bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.Name = "WRDBodyVelocity"
                bodyVelocity.Parent = humanoidRootPart
                _log("[Utility] Teleport: Re-created BodyVelocity during teleport.")
            end
            bodyVelocity.MaxForce = FloatMaxForce
            bodyVelocity.Velocity = FloatVelocity
            humanoid.WalkSpeed = 0 -- Stop horizontal movement while truly floating
            humanoid.Sit = false -- Ensure not sitting
        _log("[Utility] Floating: ON (BodyVelocity Applied).") -- Re-_log floating status after re-applying
        end
    else
        warn("[Utility] Teleport: Target part is invalid or missing during teleport attempt. Cannot perform teleport.")
    end
end

-- Helper function to format path components for printing (prevents table.concat error)
local function formatPathComponentsForPrint(componentsTable)
    local formatted = {}
    for _, comp in ipairs(componentsTable) do
        if type(comp) == "string" then
            table.insert(formatted, comp)
        elseif type(comp) == "table" and comp.type == "index" then
            table.insert(formatted, "GetChildren()[" .. comp.value .. "]")
        else
            table.insert(formatted, tostring(comp)) -- Fallback for unexpected types
        end
    end
    return table.concat(formatted, ".")
end

-- Robust function to get character and HumanoidRootPart
local function getCharacterAndHRP()
    local currentCharacter = player.Character
    if not currentCharacter then
        local success, result = pcall(function() return player.CharacterAdded:Wait() end)
        if success and result then
            currentCharacter = result
        else
            warn("Failed to get character: " .. tostring(result))
            return nil, nil
        end
    end

    local currentHrp = nil
    local attempts = 0
    while attempts < 100 do -- Try for up to 10 seconds
        if currentCharacter and currentCharacter.Parent then
            currentHrp = currentCharacter:FindFirstChild("HumanoidRootPart")
            if currentHrp then break end
        end
        task.wait(0.1)
        attempts = attempts + 1
        if not currentCharacter or not currentCharacter.Parent then
            -- Re-attempt to get character if it disappears
            local success, result = pcall(function() return player.Character or player.CharacterAdded:Wait() end)
            if success and result then
                currentCharacter = result
            end
        end
    end
    return currentCharacter, currentHrp
end


-- Fires connections for a given RBXScriptSignal
local function fireConnections(connections, eventName)
    if connections then
        for _, conn in pairs(connections) do
            if typeof(conn) == "RBXScriptConnection" and type(conn.Fire) == "function" then
                local success, err = pcall(function() conn:Fire() end)
                if not success then
                    _log("Failed to fire " .. eventName .. " connection: " .. tostring(err))
                end
            else
                _log("Warning: Invalid " .. eventName .. " connection. Type: " .. typeof(conn))
            end
        end
    end
end

-- Simulates a button click (general purpose)
local function clickButton(button)
    if button and button.Visible and button.Active then
        _log("Clicking: " .. button.Name)
        local successDown, resultDown = pcall(function() return getconnections(button.MouseButton1Down) end)
        if successDown and type(resultDown) == "table" then
            fireConnections(resultDown, "MouseButton1Down")
        end
        task.wait(0.05)
        local successClick, resultClick = pcall(function() return getconnections(button.MouseButton1Click) end)
        if successClick and type(resultClick) == "table" then
            fireConnections(resultClick, "MouseButton1Click")
        end
        task.wait(0.05)
        local successUp, resultUp = pcall(function() return getconnections(button.MouseButton1Up) end)
        if successUp and type(resultUp) == "table" then
            fireConnections(resultUp, "MouseButton1Up")
        end
    else
        warn("Cannot click button: " .. (button and button.Name or "nil") .. ". Not visible or active.")
    end
end


-- Checks if the minigame is currently active based on the hotbar UI
local function isMinigameActive()
    local hotbarApp = playerGui:FindFirstChild(FROSTCLAWS_HOTBAR_APP_NAME)
    if hotbarApp then
        _log("DEBUG: Found MinigameHotbarApp. Enabled: " .. tostring(hotbarApp.Enabled))
        if hotbarApp.Enabled then
            _logFinding("minigame", "Minigame", true)
            return true
        else
            _logFinding("minigame", "Minigame", false)
            return false
        end
    else
        _log("DEBUG: MinigameHotbarApp not found.")
        _logFinding("minigame", "Minigame", false)
        return false
    end
end

-- Handles clicking of hotbar abilities (Drop and Sword)
local function handleHotbarAbilities()
    if not scoreIncreasingActionsAllowed then
        _log("Hotbar abilities paused due and to score control.")
        return
    end

    local hotbarApp = playerGui:FindFirstChild(FROSTCLAWS_HOTBAR_APP_NAME)
    if hotbarApp then
        local hotbarFrame = hotbarApp:FindFirstChild("Hotbar")
        if hotbarFrame then
            local dropBtnContainer = hotbarFrame:FindFirstChild(DROP_BUTTON_NAME)
            local dropBtn = dropBtnContainer and dropBtnContainer:FindFirstChild("Button")
            local swordBtnContainer = hotbarFrame:FindFirstChild(SWORD_BUTTON_NAME)
            local swordBtn = swordBtnContainer and swordBtnContainer:FindFirstChild("Button")

            if dropBtn and dropBtn.Visible and dropBtn.Active then
                clickButton(dropBtn)
                _log("Clicked DropButton.")
            else
                _logFinding("drop_button", "Drop Button (nested)", false)
            end
            task.wait(0.1)
            if swordBtn and swordBtn.Visible and swordBtn.Active then
                clickButton(swordBtn)
                _log("Clicked SwordButton.")
            else
                _logFinding("sword_button", "Sword Button (nested)", false)
            end
        else
            _logFinding("hotbar_frame", "Hotbar Frame", false)
        end
    else
        _logFinding("hotbar_app", "Hotbar App", false)
    end
end

-- Finds the CoconutBonkInterior instance
local function findCoconutBonkInterior()
    if not workspace.Interiors then
        _log("DEBUG: findCoconutBonkInterior: workspace.Interiors NOT found.")
        return nil
    end
    -- Search directly within Interiors children for the CoconutBonkInterior (which might be a model)
    for _, interior in ipairs(workspace.Interiors:GetChildren()) do
        if interior.Name:find(COCONUT_BONK_INTERIOR_BASE_NAME, 1, true) then
            _log("DEBUG: findCoconutBonkInterior: Found CoconutBonkInterior: " .. interior.Name)
            return interior
        end
        -- If it's a model, check its children for the interior (as per user's original findTargetPartDynamic logic)
        if interior:IsA("Model") then
            for _, nestedChild in ipairs(interior:GetChildren()) do
                if nestedChild.Name:find(COCONUT_BONK_INTERIOR_BASE_NAME, 1, true) then
                    _log("DEBUG: findCoconutBonkInterior: Found nested CoconutBonkInterior: " .. nestedChild.Name .. " inside " .. interior.Name)
                    return nestedChild
                end
            end
        end
    end
    _log("DEBUG: findCoconutBonkInterior: CoconutBonkInterior NOT found.")
    return nil
end

-- Finds the Pets container within the minigame interior
local function findPetsContainer()
    local interior = findCoconutBonkInterior()
    if not interior then return nil end
    local gameFolder = interior:FindFirstChild("Game")
    if gameFolder then
        local bins = gameFolder:FindFirstChild("Bins")
        if bins then
            local pets = bins:FindFirstChild("Pets")
            if pets then
                _log("DEBUG: findPetsContainer: Found Pets container.")
                return pets
            end
        end
    end
    _log("DEBUG: findPetsContainer: Pets container NOT found.")
    return nil
end

-- NEW: Function to check if the boat hierarchy is found
local function isBoatHierarchyFound()
    _log("DEBUG: isBoatHierarchyFound: Checking if boat hierarchy is found...")
    local bonkInterior = findCoconutBonkInterior() -- This function now handles nested "Game" search implicitly
    if bonkInterior then
        _log("DEBUG: isBoatHierarchyFound: Found bonkInterior: " .. bonkInterior.Name)
        local gameFolder = bonkInterior:FindFirstChild("Game")
        if gameFolder then
            _log("DEBUG: isBoatHierarchyFound: Found Game folder: " .. gameFolder.Name)
            local bins = gameFolder:FindFirstChild("Bins")
            if bins then
                local boats = bins:FindFirstChild("Boats")
                if boats then
                    _log("DEBUG: isBoatHierarchyFound: Found Boats folder: " .. boats.Name .. ". Boat hierarchy FOUND.")
                    return true
                else
                    _log("DEBUG: isBoatHierarchyFound: 'Boats' folder NOT found under Bins.")
                end
            else
                _log("DEBUG: isBoatHierarchyFound: 'Bins' folder NOT found under Game.")
            end
        else
            _log("DEBUG: isBoatHierarchyFound: 'Game' folder NOT found under bonkInterior.")
        end
    else
        _log("DEBUG: isBoatHierarchyFound: bonkInterior NOT found.")
    end
    _log("DEBUG: isBoatHierarchyFound: Boat hierarchy NOT found.")
    return false
end


-- Handles teleportation to "raider" models (excluding specific keywords)
-- Returns true if a raider was found and teleported to, false otherwise.
local function handleTeleportToModels()
    -- This function will only attempt to teleport if the main script is enabled
    -- and the raider teleportation feature is active.
    -- The check for scriptEnabled and teleportToRaidersActive is crucial here.
    -- If this function is called from the boatTeleportationTask, it already implies
    -- that boatTeleportation is active, but we still need to respect teleportToRaidersActive.
    if not teleportToRaidersActive then
        isThreatDetectedAndHandled = false -- No threat handled if feature is off
        return false
    end

    local petsContainer = findPetsContainer()
    local currentCharacter, hrp = getCharacterAndHRP()
    local bonkInterior = findCoconutBonkInterior()

    if not petsContainer or not bonkInterior or not hrp or not hrp.Parent == currentCharacter then
        _log("Teleport conditions not met (petsContainer, bonkInterior, or HRP missing).")
        isThreatDetectedAndHandled = false
        return false
    end

    local gameFolder = bonkInterior:FindFirstChild("Game")
    local goldPileRoot = gameFolder and gameFolder:FindFirstChild("GoldPile") and gameFolder.GoldPile:FindFirstChild("Root")
    if not goldPileRoot or not goldPileRoot:IsA("BasePart") then
        _log("No valid GoldPile Root for raider detection.")
        isThreatDetectedAndHandled = false
        return false
    end
    local goldPos = goldPileRoot.Position

    for _, model in ipairs(petsContainer:GetChildren()) do
        if model:IsA("Model") then
            local nameLower = model.Name:lower()
            local shouldExclude = false
            for _, keyword in ipairs(EXCLUDED_MODEL_KEYWORDS) do
                if nameLower:find(keyword) then
                    shouldExclude = true
                    break
                end
            end
            if not shouldExclude then
                local targetPart = model.PrimaryPart or model:FindFirstChild("HumanoidRootPart")
                if targetPart and targetPart:IsA("BasePart") then
                    local dist = (targetPart.Position - goldPos).magnitude
                    if dist <= GOLD_PILE_GUARD_RADIUS then
                        _log("Threat: " .. model.Name .. " within guard radius (" .. math.floor(dist) .. " studs). Teleporting.")
                        local teleportPos = targetPart.Position + Vector3.new(0, 5, 0) -- Teleport slightly above
                        local lookAtPos = targetPart.Position -- Look at the raider's position
                        -- Ensure HRP is still valid before teleporting
                        if hrp and hrp.Parent == currentCharacter then
                            hrp.CFrame = CFrame.lookAt(teleportPos, lookAtPos)
                            task.wait(0.005) -- Small wait after teleport
                            isThreatDetectedAndHandled = true -- Mark that a threat was handled
                            return true -- Indicate that a threat was detected and handled
                        end
                    end
                end
            end
        end
    end
    _log("No raiders found within guard radius.")
    isThreatDetectedAndHandled = false -- No threat handled
    return false -- No threat detected or handled
end

-- Checks the current score and adjusts `scoreIncreasingActionsAllowed`
local function checkScoreAndAdjustActions()
    local success, valueLabel = pcall(function()
        return playerGui:WaitForChild("MinigameInGameApp", 5)
            :WaitForChild("Body", 5)
            :WaitForChild("Right", 5)
            :WaitForChild("Container", 5)
            :WaitForChild("ValueLabel", 5)
    end)

    if not success or not valueLabel or not valueLabel:IsA("TextLabel") then
        _log("❌ ValueLabel not found or not TextLabel after waiting.")
        scoreIncreasingActionsAllowed = true -- Default to allowed if score cannot be read
        return
    end
    _logFinding("score_label", "Score ValueLabel", true)

    local currentScore = tonumber(valueLabel.Text)
    if not currentScore then
        _log("Could not parse score: " .. tostring(valueLabel.Text))
        scoreIncreasingActionsAllowed = true -- Default to allowed if score cannot be parsed
        return
    end

    local upperThreshold = TARGET_SCORE + SCORE_UPPER_TOLERANCE
    local lowerThreshold = TARGET_SCORE - SCORE_LOWER_TOLERANCE

    if currentScore > upperThreshold and scoreIncreasingActionsAllowed then
        scoreIncreasingActionsAllowed = false
        _log(string.format("Score %d > upper threshold (%d). Pausing actions.", currentScore, upperThreshold))
    elseif currentScore < lowerThreshold and not scoreIncreasingActionsAllowed then
        scoreIncreasingActionsAllowed = true
        _log(string.format("Score %d < lower threshold (%d). Resuming actions.", currentScore, lowerThreshold))
    end
    _log("Current Score: " .. currentScore)
end

-- Gets the teleport ring instance for initial teleport
local function getTeleportRingInstance()
    local ring
    local attempts = 0
    local MAX_RING_ATTEMPTS = 60 -- Max attempts (30 seconds)
    _log("Starting search for Teleport Ring...")
    repeat
        local interiors = workspace:FindFirstChild("Interiors")
        local summerfest = interiors and interiors:FindFirstChild("MainMap!Summerfest")
        local joinZone = summerfest and summerfest:FindFirstChild("CoconutBonkJoinZone")
        if joinZone and typeof(joinZone) == "Instance" and type(joinZone.FindFirstChild) == "function" then
            local success, result = pcall(function() return joinZone:FindFirstChild("Ring") end)
            if success then
                ring = result
                if ring then
                    _log("Found Teleport Ring at attempt: " .. attempts)
                    break
                end
            else
                _log("Error during getTeleportRingInstance: " .. tostring(result))
            end
        else
            _logFinding("join_zone", "CoconutBonkJoinZone", false)
        end
        task.wait(0.5)
        attempts = attempts + 1
    until ring or attempts >= MAX_RING_ATTEMPTS
    if not ring then
        warn("Failed to find Teleport Ring after maximum attempts.")
    end
    return ring
end

-- Performs an initial teleport to the game's entry point
local function initialTeleport()
    local currentCharacter, hrp = getCharacterAndHRP()
    local ring = getTeleportRingInstance()
    if ring and hrp and hrp.Parent == currentCharacter then
        local success, err = pcall(function()
            hrp.CFrame = ring.CFrame + Vector3.new(0, 5, 0) -- Teleport slightly above the ring
        end)
        if not success then
            warn("Initial teleport failed: " .. tostring(err))
        else
            _log("Initial teleport successful.")
            task.wait(0.5)
        end
    else
        warn("No valid ring or HRP for initial teleport. Skipping.")
    end
end

-- Explicit "finding minigame" logic as requested (for the main minigame)
local isFindingMinigame = false
local function startFindingMinigame()
    if isFindingMinigame then return end
    isFindingMinigame = true
    _log("Starting to print 'finding minigame...' repeatedly.")
    findingMinigameCoroutine = coroutine.wrap(function()
        while isFindingMinigame do
            _log("finding minigame...")
            task.wait(0.5)
        end
        _log("'finding minigame...' printing stopped.")
    end)
    task.spawn(findingMinigameCoroutine)
end

local function stopFindingMinigame()
    if isFindingMinigame then
        isFindingMinigame = false
        if findingMinigameCoroutine then
            -- No explicit way to cancel a running coroutine, but the loop condition handles it.
            findingMinigameCoroutine = nil
        end
        _log("Stopped printing 'finding minigame...'.")
    end
end

-- NEW: Explicit "finding boat minigame" logic
local function startFindingBoatMinigame()
    if isFindingBoatMinigame then
        _log("DEBUG: startFindingBoatMinigame called, but already running. Returning.")
        return
    end
    isFindingBoatMinigame = true
    _log("Starting to print 'Finding minigame bonk Interior boats...' repeatedly.")
    findingBoatMinigameCoroutine = coroutine.wrap(function()
        while isFindingBoatMinigame do
            _log("Finding minigame bonk Interior boats... (from coroutine)")
            task.wait(0.5)
        end
        _log("'Finding minigame bonk Interior boats...' printing stopped.")
    end)
    task.spawn(findingBoatMinigameCoroutine)
end

local function stopFindingBoatMinigame()
    if isFindingBoatMinigame then
        isFindingBoatMinigame = false
        if findingBoatMinigameCoroutine then
            findingBoatMinigameCoroutine = nil
        end
        _log("Stopped printing 'Finding minigame bonk Interior boats...'.")
    end
end

-- Custom Draggable function (REVISED FOR INDEPENDENT DRAGGING)
-- Now takes optional callbacks for drag start and end.
local function makeDraggable(guiElement, targetFrame, onDragStartCallback, onDragEndCallback)
    local dragging = false -- Local dragging state for this specific draggable instance
    local dragStartMousePositionX = 0
    local dragStartMousePositionY = 0
    local dragStartFramePositionX = 0
    local dragStartFramePositionY = 0

    guiElement.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStartMousePositionX = input.Position.X
            dragStartMousePositionY = input.Position.Y
            dragStartFramePositionX = targetFrame.AbsolutePosition.X
            dragStartFramePositionY = targetFrame.AbsolutePosition.Y
            if onDragStartCallback then onDragStartCallback() end -- Call callback on drag start
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and dragging then
            local currentMouseX = input.Position.X
            local currentMouseY = input.Position.Y

            local deltaX = currentMouseX - dragStartMousePositionX
            local deltaY = currentMouseY - dragStartMousePositionY

            local newAbsoluteX = dragStartFramePositionX + deltaX
            local newAbsoluteY = dragStartFramePositionY + deltaY

            if targetFrame and targetFrame.Parent then
                targetFrame.Position = UDim2.new(0, newAbsoluteX, 0, newAbsoluteY)
            end
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            dragging = false
            if onDragEndCallback then onDragEndCallback() end -- Call callback on drag end
        end
    end)
end


-- --- GUI CREATION ---
-- This function now creates the single consolidated console UI
local function createConsoleUI()
    _log("Creating consolidated console UI...")
    mainConsoleGui = Instance.new("ScreenGui", playerGui) -- Assign to global variable
    mainConsoleGui.Name = "MainConsole"

    local frame = Instance.new("Frame", mainConsoleGui)
    frame.Size = UDim2.new(0.6, 0, 0.5, 0) -- Adjusted size to be smaller
    frame.Position = UDim2.new(0.2, 0, 0.25, 0) -- Adjusted position to keep it centered
    frame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.new(1, 1, 1)
    frame.Active = true -- Main frame active for general interaction

    local header = Instance.new("Frame", frame)
    header.Size = UDim2.new(1, 0, 0, 50)
    header.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
    header.Active = true -- Make header active to capture mouse events for dragging

    -- Apply custom draggable behavior to the header, making it drag the main frame
    makeDraggable(header, frame)


    -- Main Script Toggle Button (far left)
    local toggleBtn = Instance.new("TextButton", header)
    toggleBtn.Size = UDim2.new(0, 120, 1, 0)
    toggleBtn.Position = UDim2.new(0, 5, 0, 0) -- Positioned to the far left with 5px padding
    toggleBtn.BackgroundColor3 = Color3.new(0.2, 0.2, 0.8) -- Blue (initial state)
    toggleBtn.Text = "Script: OFF"
    toggleBtn.TextColor3 = Color3.new(1, 1, 1)
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.FontSize = Enum.FontSize.Size14
    toggleBtn.TextSize = 18 -- Slightly smaller text

    local function updateToggleUI()
        if scriptEnabled then
            toggleBtn.Text = "Script: ON"
            toggleBtn.BackgroundColor3 = Color3.new(0.2, 0.8, 0.2) -- Green
        else
            toggleBtn.Text = "Script: OFF"
            toggleBtn.BackgroundColor3 = Color3.new(0.8, 0.2, 0.2) -- Red
        end
    end
    updateToggleUI() -- Set initial state

    -- Connect main script toggle button
    toggleBtn.MouseButton1Click:Connect(function()
        local prevState = scriptEnabled
        scriptEnabled = not scriptEnabled
        updateToggleUI()
        _log("Script toggled: " .. tostring(scriptEnabled))

        if scriptEnabled and not prevState then
            -- Actions to take when script is enabled
            local currentCharacter, hrp = getCharacterAndHRP()
            local ring = getTeleportRingInstance()
            if ring and hrp and hrp.Parent == currentCharacter then
                local success, err = pcall(function()
                    hrp.CFrame = ring.CFrame + Vector3.new(0, 5, 0)
                end)
                if not success then
                    warn("Teleport on toggle failed: " .. tostring(err))
                else
                    _log("Teleported to minigame entry on script enable.")
                    task.wait(0.5)
                end
            else
                warn("Could not teleport: ring or HRP missing for initial teleport on toggle ON.")
            end
        else
            -- Actions to take when script is disabled
            scoreIncreasingActionsAllowed = true -- Reset score control on disable
            stopFindingMinigame() -- Stop the "finding minigame" loop
            _log("All main script features deactivated.")
            -- Do NOT force isBoatTeleportCycleRunning to false here.
            -- Its state is independent.
        end
    end)

    -- New: Boat Teleportation Button
    local boatTeleportBtn = Instance.new("TextButton", header)
    boatTeleportBtn.Name = "BoatTeleportationBtn" -- Added a name for easier reference
    boatTeleportBtn.Size = UDim2.new(0, 180, 1, 0) -- Adjusted width to fit "Boat Teleportation: ON/OFF"
    boatTeleportBtn.Position = UDim2.new(0, toggleBtn.Position.X.Offset + toggleBtn.Size.X.Offset + 10, 0, 0)
    boatTeleportBtn.TextColor3 = Color3.new(1, 1, 1) -- White text for contrast
    boatTeleportBtn.Font = Enum.Font.GothamBold
    boatTeleportBtn.FontSize = Enum.FontSize.Size14
    boatTeleportBtn.TextSize = 18
    boatTeleportBtn.TextWrapped = true
    boatTeleportBtn.TextScaled = true

    local function updateBoatTeleportUI()
        if isBoatTeleportCycleRunning then
            boatTeleportBtn.Text = "Boat Teleportation: ON"
            boatTeleportBtn.BackgroundColor3 = Color3.new(0.2, 0.8, 0.2) -- Green
        else
            boatTeleportBtn.Text = "Boat Teleportation: OFF"
            boatTeleportBtn.BackgroundColor3 = Color3.new(0.8, 0.2, 0.2) -- Red
        end
    end
    updateBoatTeleportUI() -- Set initial state

    -- Connect boat teleportation button to its toggle logic
    boatTeleportBtn.MouseButton1Click:Connect(function()
        isBoatTeleportCycleRunning = not isBoatTeleportCycleRunning -- Only change state here
        updateBoatTeleportUI() -- Only update UI here
        _log("Boat Teleportation toggled: " .. tostring(isBoatTeleportCycleRunning))

        if isBoatTeleportCycleRunning then
            -- No specific actions on turning ON here, main loop handles activation
        else -- If turning OFF, clean up
            toggleFloating(false)
            deactivateNoclip()
            stopFindingBoatMinigame()
            hasLoggedBoatFound = false
            hasLoggedInvalidPaths = false -- Reset this flag too
            if boatTeleportationTask and coroutine.status(boatTeleportationTask) ~= "dead" then
                _log("Stopping automated boat teleportation task due to button OFF.")
                -- The task's while loop condition will handle its exit.
            end
        end
    end)


    -- Close Button (restored to v38 properties)
    local closeBtn = Instance.new("TextButton", header)
    closeBtn.Size = UDim2.new(0, 100, 1, 0)
    closeBtn.Position = UDim2.new(1, -100, 0, 0)
    closeBtn.BackgroundColor3 = Color3.new(0.8, 0.2, 0.2) -- Red
    closeBtn.Text = "X"
    closeBtn.TextColor3 = Color3.new(1, 1, 1)
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.FontSize = Enum.FontSize.Size14
    closeBtn.TextSize = 24

    -- Connect close button
    closeBtn.MouseButton1Click:Connect(function()
        mainConsoleGui:Destroy() -- Destroy the main console GUI
        consoleTextLabel = nil -- Clear reference
        scriptEnabled = false -- Ensure main script is disabled on close
        _log("Main Console closed. All scripts disabled.")
        scoreIncreasingActionsAllowed = true -- Reset score control on disable
        stopFindingMinigame() -- Stop the "finding minigame" loop
        stopFindingBoatMinigame() -- Stop boat finding messages on close
        isBoatTeleportCycleRunning = false -- Ensure boat teleport cycle stops
        toggleFloating(false) -- Ensure floating is off
        deactivateNoclip() -- Ensure noclip is off
        hasLoggedBoatFound = false -- Reset for clean restart
        hasLoggedInvalidPaths = false -- Reset for clean restart
        if boatTeleportationTask and coroutine.status(boatTeleportationTask) ~= "dead" then
            _log("Stopping automated boat teleportation task due to console close.")
            -- Setting the flag will cause its loop to exit
        end
    end)

    -- Title Label (positioned to be centered in the header, with new text)
    local titleLabel = Instance.new("TextLabel", header)
    titleLabel.Size = UDim2.new(1, 0, 1, 0) -- Span full width of header
    titleLabel.Position = UDim2.new(0, 0, 0, 0) -- Top-left of header
    titleLabel.BackgroundTransparency = 1 -- Keep background transparent
    titleLabel.TextColor3 = Color3.new(1, 1, 1)
    titleLabel.Text = "SummerFest 2025 Week 1" -- Renamed title
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.FontSize = Enum.FontSize.Size18
    titleLabel.TextSize = 22
    titleLabel.TextXAlignment = Enum.TextXAlignment.Center -- Center text horizontally
    titleLabel.TextYAlignment = Enum.TextYAlignment.Center -- Center text vertically
    titleLabel.TextScaled = true -- Crucial: Scale text to fit within the label bounds

    -- NEW: Content Area Frame to hold both Console Log and Changelog
    local contentArea = Instance.new("Frame", frame)
    contentArea.Name = "ContentArea"
    contentArea.Size = UDim2.new(1, -10, 1, -100) -- Accounts for header (50) and footer (50) + 10px total padding
    contentArea.Position = UDim2.new(0, 5, 0, 55) -- Below header, 5px padding left/top
    contentArea.BackgroundTransparency = 1 -- Make it transparent
    contentArea.BorderSizePixel = 0

    -- Add UIListLayout to arrange Console Log and Changelog horizontally
    local contentLayout = Instance.new("UIListLayout", contentArea)
    contentLayout.FillDirection = Enum.FillDirection.Horizontal
    contentLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    contentLayout.Padding = UDim.new(0, 10) -- 10 pixels padding between the two sections

    -- Log area (with ScrollingFrame) - now child of contentArea
    local logFrame = Instance.new("Frame", contentArea)
    logFrame.Size = UDim2.new(0.5, -5, 1, 0) -- Half width of contentArea, minus 5px for padding
    logFrame.Position = UDim2.new(0, 0, 0, 0) -- Position handled by UIListLayout
    logFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.15)
    logFrame.BorderSizePixel = 1
    logFrame.BorderColor3 = Color3.new(0.5, 0.5, 0.5)
    logFrame.Active = false -- Make log frame inactive so it doesn't interfere with dragging

    local textScroller = Instance.new("ScrollingFrame", logFrame)
    textScroller.Size = UDim2.new(1, 0, 1, 0)
    textScroller.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be updated dynamically by AutomaticCanvasSize
    textScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
    textScroller.BackgroundTransparency = 1
    textScroller.ScrollBarImageColor3 = Color3.new(0.7, 0.7, 0.7)
    textScroller.ScrollBarThickness = 8

    local logLabel = Instance.new("TextLabel", textScroller)
    logLabel.Name = "LogTextLabel"
    logLabel.Size = UDim2.new(1, 0, 0, 0) -- Height will adjust with AutomaticCanvasSize
    logLabel.Position = UDim2.new(0, 0, 0, 0)
    logLabel.BackgroundTransparency = 1
    logLabel.TextColor3 = Color3.new(1, 1, 1)
    logLabel.TextXAlignment = Enum.TextXAlignment.Left
    logLabel.TextYAlignment = Enum.TextYAlignment.Top
    logLabel.TextWrapped = true
    logLabel.Font = Enum.Font.Code
    logLabel.FontSize = Enum.FontSize.Size14
    logLabel.Text = "Console Log:\n"
    logLabel.AutomaticSize = Enum.AutomaticSize.Y -- Make label height adjust to content
    consoleTextLabel = logLabel -- Assign to global variable

    _log("Console UI created.")
    -- Add the script version to the console log immediately after creation
    _log("Script Version: 2025-07-07_ConsolidatedUIAndLogic_v111") -- Updated version number

    -- NEW: Changelog Frame
    local changelogFrame = Instance.new("Frame", contentArea)
    changelogFrame.Name = "ChangelogFrame"
    changelogFrame.Size = UDim2.new(0.5, -5, 1, 0) -- Half width of contentArea, minus 5px for padding
    changelogFrame.Position = UDim2.new(0, 0, 0, 0) -- Position handled by UIListLayout
    changelogFrame.BackgroundColor3 = Color3.new(0.15, 0.15, 0.15)
    changelogFrame.BorderSizePixel = 1
    changelogFrame.BorderColor3 = Color3.new(0.5, 0.5, 0.5)
    changelogFrame.Active = false

    local changelogScroller = Instance.new("ScrollingFrame", changelogFrame)
    changelogScroller.Size = UDim2.new(1, 0, 1, 0)
    changelogScroller.CanvasSize = UDim2.new(0, 0, 0, 0)
    changelogScroller.AutomaticCanvasSize = Enum.AutomaticSize.Y
    changelogScroller.BackgroundTransparency = 1
    changelogScroller.ScrollBarImageColor3 = Color3.new(0.7, 0.7, 0.7)
    changelogScroller.ScrollBarThickness = 8

    local changelogLabel = Instance.new("TextLabel", changelogScroller)
    changelogLabel.Name = "ChangelogTextLabel"
    changelogLabel.Size = UDim2.new(1, 0, 0, 0)
    changelogLabel.Position = UDim2.new(0, 0, 0, 0)
    changelogLabel.BackgroundTransparency = 1
    changelogLabel.TextColor3 = Color3.new(1, 1, 1)
    changelogLabel.TextXAlignment = Enum.TextXAlignment.Left
    changelogLabel.TextYAlignment = Enum.TextYAlignment.Top
    changelogLabel.TextWrapped = true
    changelogLabel.Font = Enum.Font.Code
    changelogLabel.FontSize = Enum.FontSize.Size14
    changelogLabel.AutomaticSize = Enum.AutomaticSize.Y

    -- Changelog Content
    changelogLabel.Text = [[
Changelog:
v111 (2025-07-07):
- **CRITICAL FIX: Localized and Renamed Path Finder**:
    - `findInstanceFromPath` is now `local function _findInstanceByPath`. This significantly reduces the chance of global name conflicts causing "attempt to call a string value" errors. All internal calls updated.
- **Re-integrated Boat Teleportation Logic**:
    - Re-added automated boat teleportation cycle, including Noclip, Floating, and cycling through predefined paths.
    - Integrated threat handling during boat teleportation.
    - Re-added "Boat Teleportation" button to UI.
- **Removed Auto Close Reward and Auto Click Hotbar**:
    - These features remain excluded to maintain stability based on user feedback.
- **Resilient Function Calls**:
    - Maintained local aliases (`_log`, `_logFinding`) for global functions (`log`, `logFinding`) to prevent "attempt to call a string value" errors.

v110 (2025-07-07):
- **Re-integrated Boat Teleportation Logic**:
    - Re-added automated boat teleportation cycle, including Noclip, Floating, and cycling through predefined paths.
    - Integrated threat handling during boat teleportation.
    - Re-added "Boat Teleportation" button to UI.
- **Removed Auto Close Reward and Auto Click Hotbar**:
    - Removed these features to maintain stability based on user feedback.
- **Resilient Function Calls**:
    - Maintained local aliases (`_log`, `_logFinding`) for global functions (`log`, `logFinding`) to prevent "attempt to call a string value" errors.

v57 (2025-07-07):
- **Consolidated UI**: All UI elements merged into a single draggable console window.
- **Main Script Toggle**: Added ON/OFF toggle for the main script.
- **Improved Console Log**: Enhanced display with scrolling and line limits.
- **Enhanced Anti-AFK Movement**: Implemented random rotations and shifts.
- **Robust Character Retrieval**: Refined `getCharacterAndHRP` for better robustness.
- **Initial Teleport**: Performs an initial teleport to the game's entry point on script start.
]]

    -- NEW: Footer Frame for new buttons (now empty as per user request to remove auto-close/auto-click)
    local footer = Instance.new("Frame", frame)
    footer.Name = "Footer"
    footer.Size = UDim2.new(1, 0, 0, 50) -- Height for buttons
    footer.Position = UDim2.new(0, 0, 1, -50) -- Position at the bottom of the main frame
    footer.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
    footer.BorderSizePixel = 0

    -- Add UIListLayout to the footer for automatic alignment
    local listLayout = Instance.new("UIListLayout", footer)
    listLayout.FillDirection = Enum.FillDirection.Horizontal
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.Padding = UDim.new(0, 10) -- 10 pixels padding between buttons

    -- Auto Close Reward Toggle Button (REMOVED as per user request)
    -- Auto Click Hotbar Button (REMOVED as per user request)
    -- Toggle CoreGui ScreenGui Button (REMOVED as per user request)

end


-- Initial character and HRP retrieval using the robust function
character, humanoidRootPart = getCharacterAndHRP()

-- --- INITIALIZATION ---
-- This section runs once at script start to perform an.
print("--- Initializing Automated Features ---")
local initialValidationPassed = true -- Flag to track if all initial checks were successful
ValidTeleportTargets = {} -- Clear this list before initial population

local initialBonkInterior = findCoconutBonkInterior()
if not initialBonkInterior then
    _log("Initial check: CoconutBonkInterior NOT found. Automated boat teleportation will wait for it to appear.")
    initialValidationPassed = false
else
    local initialGameFolder = initialBonkInterior:FindFirstChild("Game")
    if not initialGameFolder then
        _log("Initial check: Game folder NOT found under CoconutBonkInterior. Automated boat teleportation will wait for it to appear.")
        initialValidationPassed = false
    else
        -- Attempt to validate all paths, but don't stop if one fails.
        -- We'll just _log the failure and mark the overall initial check as not fully passed.
        for i, pathComponentsTable in ipairs(TeleportLocationPaths) do
            _log("Validating dynamic path " .. i .. ": " .. formatPathComponentsForPrint(pathComponentsTable))
            -- Use initialGameFolder as the startParent for the initial validation
            local tempTargetPart = _findInstanceByPath(initialGameFolder, table.concat(pathComponentsTable, "."), 0.2, 3)
            if tempTargetPart then
                table.insert(ValidTeleportTargets, {part = tempTargetPart, debugPath = table.concat(pathComponentsTable, ".")})
                _log("[Utility Debug] Successfully validated path " .. i .. ". Found at: " .. table.concat(pathComponentsTable, "."))
            else
                _log("Initial check: Required teleport part NOT FOUND for path (Component issue: '" .. table.concat(pathComponentsTable, ".") .. "'). Automated boat teleportation for this path will wait.")
                initialValidationPassed = false -- Mark overall initial validation as not fully passed
            end
        end
    end
end

if not initialValidationPassed then
    _log("Initial setup complete, but some required teleport locations were not found. Automated boat teleportation will activate dynamically when all parts are ready.")
else
    _log("All " .. #ValidTeleportTargets .. " teleport locations validated successfully through dynamic search at script start.")
end

createConsoleUI() -- Create the main consolidated console UI
task.wait(0.1) -- Small wait to ensure UI elements are fully rendered and accessible
initialTeleport() -- Perform initial teleport regardless of scriptEnabled state

-- Function to dynamically re-validate teleport paths
local function revalidateTeleportPaths()
    local tempValidTargets = {}
    local bonkInterior = findCoconutBonkInterior()
    if not bonkInterior then
        _log("DEBUG: revalidateTeleportPaths: CoconutBonkInterior not found.")
        ValidTeleportTargets = {} -- Clear targets if main interior is gone
        return false
    end

    local gameFolder = bonkInterior:FindFirstChild("Game")
    if not gameFolder then
        _log("DEBUG: revalidateTeleportPaths: Game folder not found under CoconutBonkInterior.")
        ValidTeleportTargets = {} -- Clear targets if Game folder is gone
        return false
    end

    local anyPathFound = false
    for i, pathComponentsTable in ipairs(TeleportLocationPaths) do
        -- Start searching from gameFolder for the rest of the path
        local targetPart = _findInstanceByPath(gameFolder, table.concat(pathComponentsTable, "."), 0.2, 3)
        if targetPart then
            table.insert(tempValidTargets, {part = targetPart, debugPath = table.concat(pathComponentsTable, ".")})
            anyPathFound = true
        else
            _log("DEBUG: revalidateTeleportPaths: Path " .. formatPathComponentsForPrint(pathComponentsTable) .. " failed validation. Reason: not found.")
            -- Do NOT set currentPathsValid to false or break here. Continue to find other valid paths.
        end
    end

    ValidTeleportTargets = tempValidTargets -- Update the global list with only the found valid targets
    return anyPathFound -- Return true if at least one path was found
end


-- --- MAIN LOOP ---
while true do
    -- Boat Teleportation logic (runs ONLY if isBoatTeleportCycleRunning is true)
    if isBoatTeleportCycleRunning then
        local boatHierarchyPresent = isBoatHierarchyFound() -- This will also _log its own debugs
        local currentPathsAreValid = revalidateTeleportPaths() -- Re-validate paths dynamically

        if boatHierarchyPresent and currentPathsAreValid then
            -- Hierarchy IS present AND at least ONE path IS valid: Initiate teleportation
            stopFindingBoatMinigame() -- Stop "Finding..." messages
            if not hasLoggedBoatFound then
                _log("Minigame bonk Interior boats found! Initiating automated teleportation.")
                hasLoggedBoatFound = true
                hasLoggedInvalidPaths = false -- Reset invalid paths flag
            end

            if not boatTeleportationTask or coroutine.status(boatTeleportationTask) == "dead" then
                _log("DEBUG: Spawning automated boat teleportation task.")
                boatTeleportationTask = task.spawn(function()
                    activateNoclip()
                    toggleFloating(true)
                    currentTeleportIndex = 1

                    -- The loop condition now checks isBoatTeleportCycleRunning and if there are valid targets
                    while isBoatTeleportCycleRunning and #ValidTeleportTargets > 0 do
                        local remainingDelay = TeleportDelay
                        local threatDetectedAndHandled = false

                        -- Loop to check for threats in smaller chunks of the TeleportDelay
                        while remainingDelay > 0 and isBoatTeleportCycleRunning and #ValidTeleportTargets > 0 do
                            local threatFound = handleTeleportToModels()
                            if threatFound then
                                threatDetectedAndHandled = true
                                _log("Threat detected and handled. Pausing boat teleportation for " .. THREAT_HANDLING_DELAY .. " " .. "seconds.")
                                task.wait(THREAT_HANDLING_DELAY) -- Pause for a moment to deal with the threat
                                _log("Resuming boat teleportation cycle.")
                                break -- Exit the small-chunk delay loop immediately after handling threat
                            end
                            task.wait(math.min(remainingDelay, 0.5)) -- Wait in small chunks (e.g., 0.5s), checking for threats
                            remainingDelay = remainingDelay - 0.5
                        end

                        if not isBoatTeleportCycleRunning or #ValidTeleportTargets == 0 then
                            break -- Exit main loop if conditions change during delay or threat handling
                        end

                        -- Re-validate paths after potential threat handling or delay
                        local revalidationSuccess = revalidateTeleportPaths()
                        if not revalidationSuccess or #ValidTeleportTargets == 0 then
                            warn("Automated boat teleportation task stopping: No valid targets found during revalidation.")
                            break -- Exit the task loop if no valid targets remain
                        end

                        local targetEntry = ValidTeleportTargets[currentTeleportIndex]
                        if targetEntry and targetEntry.part and targetEntry.part.Parent then
                            _log("\n--- Teleporting Cycle Step: " .. currentTeleportIndex .. " of " .. #ValidTeleportTargets .. " ---")
                            performFloatTeleport(targetEntry)
                            currentTeleportIndex = currentTeleportIndex + 1
                            if currentTeleportIndex > #ValidTeleportTargets then
                                currentTeleportIndex = 1
                            end
                        else
                            warn("Teleport target invalid or removed for index " .. currentTeleportIndex .. " during cycle. Re-validating paths.")
                            -- If a specific target becomes invalid, re-validate immediately and continue the loop.
                            -- The next iteration will pick a valid target or exit if no targets are left.
                            task.wait(0.1) -- Small pause before re-evaluating
                            local revalidationCheck = revalidateTeleportPaths() -- Immediate revalidation
                            if not revalidationCheck or #ValidTeleportTargets == 0 then
                                warn("Automated boat teleportation task stopping: No valid targets after immediate revalidation.")
                                break -- Exit if revalidation still yields no valid targets
                            end
                            -- Adjust currentTeleportIndex if the list of targets changed size
                            if currentTeleportIndex > #ValidTeleportTargets then
                                currentTeleportIndex = 1
                            end
                        end
                        -- No task.wait(TeleportDelay) here, as it's handled by the chunked wait above.
                    end
                    _log("Automated boat teleportation task finished.")
                    toggleFloating(false) -- Clean up after task finishes
                    deactivateNoclip()
                end)
            end
        elseif boatHierarchyPresent and not currentPathsAreValid then
            -- Hierarchy IS present, but NO paths are valid: _log, but no teleportation.
            stopFindingBoatMinigame() -- Stop "Finding..." messages (as hierarchy is found)
            if not hasLoggedInvalidPaths then
                _log("Minigame bonk Interior boats found, but teleportation paths are invalid. Waiting for valid paths.")
                hasLoggedInvalidPaths = true -- Set to true so it doesn't spam this message
                hasLoggedBoatFound = false -- Reset found flag
            end

            -- Ensure teleportation task is stopped if it was running (e.g., paths became invalid mid-run)
            if boatTeleportationTask and coroutine.status(boatTeleportationTask) ~= "dead" then
                _log("Stopping automated boat teleportation task as paths are invalid.")
                -- The task's while loop condition will handle its exit.
                -- Explicitly clean up noclip/floating for this case.
                toggleFloating(false)
                deactivateNoclip()
            end
        else -- not boatHierarchyPresent
            -- Hierarchy is NOT present: Show "Finding..." message
            startFindingBoatMinigame()
            hasLoggedBoatFound = false -- Reset for next "found" transition
            hasLoggedInvalidPaths = false -- Reset invalid paths flag

            -- Ensure teleportation task is stopped if hierarchy is lost
            if boatTeleportationTask and coroutine.status(boatTeleportationTask) ~= "dead" then
                _log("Stopping automated boat teleportation task as hierarchy is lost.")
                -- The task's while loop condition will handle its exit.
                -- Explicitly clean up noclip/floating for this case.
                toggleFloating(false)
                deactivateNoclip()
            end
        end
    else
        -- Boat Teleportation button is OFF
        stopFindingBoatMinigame() -- Ensure messages stop
        hasLoggedBoatFound = false -- Reset for next "found" transition if button is turned back ON
        hasLoggedInvalidPaths = false -- Reset invalid paths flag

        if boatTeleportationTask and coroutine.status(boatTeleportationTask) ~= "dead" then
            _log("Stopping automated boat teleportation task as button is OFF.")
            -- The task's while loop condition will handle its exit.
            toggleFloating(false)
            deactivateNoclip()
        end
    end


    -- Main Minigame logic (runs ONLY if scriptEnabled is true)
    if scriptEnabled then
        if isMinigameActive() then
            stopFindingMinigame()
            -- ... (rest of main minigame active logic - checkScoreAndAdjustActions, handleHotbarAbilities, handleTeleportToModels) ...
            local ok, err = pcall(checkScoreAndAdjustActions)
            if not ok then warn("Error in checkScoreAndAdjustActions: " .. tostring(err)) end

            local tda = playerGui:FindFirstChild("TreasureDefenseExplainerApp")
            if tda and tda.Enabled then
                local startScreen = tda:FindFirstChild("StartScreen")
                if startScreen and startScreen.Visible then
                    local depthBtn = startScreen:FindFirstChild("DepthButton")
                    if depthBtn and depthBtn.Visible and depthBtn.Active then
                        local success, err = pcall(clickButton, depthBtn)
                        if not success then warn("Error clicking DepthButton: " .. tostring(err)) end
                        hasClickedStartButton = true
                    end
                end
            end
            if not (playerGui:FindFirstChild("TreasureDefenseExplainerApp") and playerGui.TreasureDefenseExplainerApp.Enabled) then
                hasClickedStartButton = false
            end

            if hotbarSpamActive then
                local ok, err = pcall(handleHotbarAbilities)
                if not ok then warn("Error in handleHotbarAbilities: " .. tostring(err)) end
                task.wait(0.1)
            end

            -- The primary handleTeleportToModels call that affects the main minigame logic.
            -- This will only run if scriptEnabled and teleportToRaidersActive are true.
            -- It will NOT affect boat teleportation if boat teleportation is active, as that has its own check.
            if teleportToRaidersActive and not isBoatTeleportCycleRunning then -- Only run if boat teleportation is NOT active
                local ok, err = pcall(handleTeleportToModels)
                if not ok then warn("Error in handleTeleportToModels (main loop): " .. tostring(err)) end
                task.wait(0.005)
            end

        else
            startFindingMinigame()
            -- ... (rest of main minigame inactive logic) ...
            local tda = playerGui:FindFirstChild("TreasureDefenseExplainerApp")
            if tda and tda.Enabled then
                local startScreen = tda:FindFirstChild("StartScreen")
                if startScreen and startScreen.Visible then
                    local depthBtn = startScreen:FindFirstChild("DepthButton")
                    if depthBtn and depthBtn.Visible and depthBtn.Active then
                        local success, err = pcall(clickButton, depthBtn)
                        if not success then warn("Error clicking DepthButton: " .. tostring(err)) end
                        hasClickedStartButton = true
                    end
                end
            end
            if not (playerGui:FindFirstChild("TreasureDefenseExplainerApp") and playerGui.TreasureDefenseExplainerApp.Enabled) then
                hasClickedStartButton = false
            end
            if not scoreIncreasingActionsAllowed then
                scoreIncreasingActionsAllowed = true
                _log("Minigame inactive, resetting score actions.")
            end
            task.wait(2)
        end

        -- Anti-AFK movement (always runs if scriptEnabled)
        local currentCharacter, hrp = getCharacterAndHRP()
        if hrp then
            local success, err = pcall(function()
                -- Generate a random axis
                local axisX = math.random(-1, 1)
                local axisY = math.random(-1, 1)
                local axisZ = math.random(-1, 1)
                -- Random angle between 5 and 20 degrees (~0.087 to 0.349 radians)
                local angleDeg = math.random(5, 20)
                local angleRad = math.rad(angleDeg)
                -- Normalize axis
                local axisLen = math.sqrt(axisX^2 + axisY^2 + axisZ^2)
                if axisLen > 0 then
                    axisX, axisY, axisZ = axisX/axisLen, axisY/axisLen, axisZ/axisLen
                else
                    axisX, axisY, axisZ = 0, 1, 0 -- fallback axis
                end
                local rotationCFrame = CFrame.fromAxisAngle(Vector3.new(axisX, axisY, axisZ), angleRad) 
                -- Random small positional shift
                local shiftX = math.random(-0.2, 0.2)
                local shiftY = math.random(-0.2, 0.2)
                local shiftZ = math.random(-0.2, 0.2)
                local shiftVec = Vector3.new(shiftX, shiftY, shiftZ)
                -- Randomly choose to rotate, shift, or both
                local actionType = math.random(1,3)
                if actionType == 1 then
                    hrp.CFrame = hrp.CFrame * rotationCFrame
                elseif actionType == 2 then
                    hrp.CFrame = hrp.CFrame * CFrame.new(shiftVec)
                else
                    hrp.CFrame = hrp.CFrame * rotationCFrame * CFrame.new(shiftVec)
                end
            end)
            if not success then
                warn("Enhanced movement error: " .. tostring(err))
            end
        end
    else
        -- If main script is disabled, make sure main minigame finding is stopped.
        stopFindingMinigame()
        task.wait(1) -- Wait longer when script is not active to reduce CPU usage
    end
    task.wait(0.01) -- Small wait for the main loop iteration
end
